{"version":3,"sources":["capture.ts","store/action-capture.ts","store/action-request-camera.ts","store/actions.ts","store/use-dispatch.ts","store/use-selector.ts","store/index.ts","components/Stream.tsx","components/Camera.tsx","components/ButtonCapture.tsx","components/ButtonRequestUserCamera.tsx","components/ButtonRequestEnvironmentCamera.tsx","components/ButtonCancelRequest.tsx","components/CancelOnPageHidden.tsx","components/Flash.tsx","components/BackgroundEmpty.tsx","components/Masking.tsx","components/App.tsx","serviceWorker.ts","update-vh.ts","index.tsx","store/action-query-permission.ts","store/action-enumerate-devices.ts"],"names":["canvas","document","createElement","ctx","getContext","captureImageFromVideo","video","a","Error","size","Math","min","videoWidth","videoHeight","width","height","sx","sy","sw","sh","dw","dh","drawImage","capture","Image","Promise","resolve","toBlob","blob","src","URL","createObjectURL","dispatch","image","type","ACTION_CAPTURE_IMAGE","data","imageSrc","requestCamera","facingMode","ACTION_REQUEST_CAMERA_START","navigator","mediaDevices","getUserMedia","stream","ACTION_REQUEST_CAMERA_SUCCESS","ACTION_REQUEST_CAMERA_ERROR","message","isActionRequestCameraStart","action","isActionRequestCameraSuccess","isActionRequestCameraError","ACTION_QUERY_PERMISSION_START","ACTION_QUERY_PERMISSION_SUCCESS","isActionQueryPermissionSuccess","ACTION_QUERY_PERMISSION_ERROR","isActionChangePermission","ACTION_ENUMERATE_DEVICES_START","ACTION_ENUMERATE_DEVICES_SUCCESS","isActionEnumerateDevicesSuccess","ACTION_ENUMERATE_DEVICES_ERROR","isActionCaptureImage","useDispatch","useReactReduxDispatch","useSelector","useReactReduxSelector","DEFAULT_STATE","version","process","devices","videoInputDeviceCount","cameraPermission","isRequestingCamera","requestCameraError","captures","reducer","state","videoInputDevices","filter","device","kind","length","getVideoInputDeviceCount","getCameraPermission","getCameraError","StreamContext","React","setStream","StreamProvider","streamProp","children","setStreamState","current","autoplay","srcObject","Provider","value","useStream","context","Camera","videoRef","className","autoPlay","ref","ButtonCapture","onTouchStart","props","disabled","setDisabled","handleTouchStart","e","preventDefault","timeout","setTimeout","clearTimeout","ButtonRequestUserCamera","onClick","handleClick","ButtonRequestEnvironmentCamera","ButtonCancelRequest","getTracks","forEach","track","stop","CancelOnPageHidden","handleVisibilityChange","hidden","addEventListener","removeEventListener","Flash","_props","divRef","start","div","classList","remove","offsetWidth","add","BackgroundEmpty","Masking","App","requestingCamera","cameraError","flashRef","flash","String","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","controller","console","log","onUpdate","onSuccess","catch","error","updateVH","documentElement","style","setProperty","innerHeight","store","createStore","rootReducer","composeWithDevTools","applyMiddleware","thunk","permissions","query","name","status","enumerateDevices","deviceInfo","getState","Blob","JSON","stringify","sendBeacon","ReactDOM","Stream","getElementById","href","origin","fetch","headers","response","contentType","get","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.91da4493.chunk.js","sourcesContent":["const canvas = document.createElement('canvas');\nconst ctx = canvas.getContext('2d');\n\nexport const captureImageFromVideo = async (video: HTMLVideoElement) => {\n  if (!ctx) throw new Error('Expected rendering context');\n  const size = Math.min(video.videoWidth, video.videoHeight);\n  canvas.width = size;\n  canvas.height = size;\n  const sx = (video.videoWidth - size) / 2;\n  const sy = (video.videoHeight - size) / 2;\n  const sw = size;\n  const sh = size;\n  const dx = 0;\n  const dy = 0;\n  const dw = size;\n  const dh = size;\n  ctx.drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh);\n  const capture = new Image(size, size);\n  const blob = await new Promise<Blob | null>((resolve) => canvas.toBlob(resolve));\n  if (!blob) throw new Error('Failed to create blob');\n  capture.src = URL.createObjectURL(blob);\n  return capture;\n};\n","import { ThunkAction } from 'redux-thunk';\nimport { captureImageFromVideo } from '../capture';\nimport { RootReducerState } from '.';\nimport {\n  ACTION_CAPTURE_IMAGE,\n  ActionCaptureImage,\n} from './actions';\n\ntype R = Promise<HTMLImageElement>\ntype S = RootReducerState\ntype E = void\ntype A = ActionCaptureImage\n\nexport type ActionCapture = ThunkAction<R, S, E, A>\n\nexport const capture = (video: HTMLVideoElement): ActionCapture => async (dispatch) => {\n  const image = await captureImageFromVideo(video);\n  dispatch<ActionCaptureImage>({\n    type: ACTION_CAPTURE_IMAGE,\n    data: {\n      imageSrc: image.src,\n    },\n  });\n  return image;\n};\n","import { ThunkAction } from 'redux-thunk';\nimport { RootReducerState } from '.';\nimport {\n  ACTION_REQUEST_CAMERA_ERROR,\n  ACTION_REQUEST_CAMERA_START,\n  ACTION_REQUEST_CAMERA_SUCCESS,\n  ActionRequestCameraError,\n  ActionRequestCameraStart,\n  ActionRequestCameraSuccess,\n} from './actions';\n\ntype R = Promise<MediaStream>\ntype S = RootReducerState\ntype E = void\ntype A = (\n  ActionRequestCameraError |\n  ActionRequestCameraStart |\n  ActionRequestCameraSuccess\n)\n\nexport type ActionRequestCamera = ThunkAction<R, S, E, A>\n\nexport const requestCamera = (facingMode: VideoFacingModeEnum = 'environment'): ActionRequestCamera => async (dispatch) => {\n  dispatch<ActionRequestCameraStart>({\n    type: ACTION_REQUEST_CAMERA_START,\n  });\n  try {\n    if (\n      typeof navigator.mediaDevices === 'undefined' ||\n      typeof navigator.mediaDevices.getUserMedia !== 'function'\n    ) {\n      throw new Error('Navigator get user media API not available');\n    }\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: {\n        facingMode,\n      },\n    });\n    dispatch<ActionRequestCameraSuccess>({\n      type: ACTION_REQUEST_CAMERA_SUCCESS,\n    });\n    return stream;\n  } catch (err) {\n    // \"Requested device not found\" (Chrome) Desktop with no camera\n    // \"Cannot read property 'getUserMedia' of undefined\" (Chrome) Served over HTTP\n    // \"Permission dismissed\" (Chrome Android) Pressed 'back' button when prompted\n    dispatch<ActionRequestCameraError>({\n      type: ACTION_REQUEST_CAMERA_ERROR,\n      data: {\n        message: err.message,\n      },\n    });\n    throw err;\n  }\n};\n","import { Action } from 'redux';\n\nexport * from './action-capture';\nexport * from './action-enumerate-devices';\nexport * from './action-query-permission';\nexport * from './action-request-camera';\n\n/* Request camera start */\n\nexport const ACTION_REQUEST_CAMERA_START = 'REQUEST_CAMERA_START';\n\nexport interface ActionRequestCameraStart extends Action<typeof ACTION_REQUEST_CAMERA_START> {}\n\nexport const isActionRequestCameraStart = (action: Action): action is ActionRequestCameraStart => (\n  action.type === ACTION_REQUEST_CAMERA_START\n);\n\n/* Request camera success */\n\nexport const ACTION_REQUEST_CAMERA_SUCCESS = 'REQUEST_CAMERA_SUCCESS';\n\nexport interface ActionRequestCameraSuccess extends Action<typeof ACTION_REQUEST_CAMERA_SUCCESS> {}\n\nexport const isActionRequestCameraSuccess = (action: Action): action is ActionRequestCameraSuccess => (\n  action.type === ACTION_REQUEST_CAMERA_SUCCESS\n);\n\n/* Request camera error */\n\nexport const ACTION_REQUEST_CAMERA_ERROR = 'REQUEST_CAMERA_ERROR';\n\nexport interface ActionRequestCameraError extends Action<typeof ACTION_REQUEST_CAMERA_ERROR> {\n  data: {\n    message: string;\n  };\n}\n\nexport const isActionRequestCameraError = (action: Action): action is ActionRequestCameraError => (\n  action.type === ACTION_REQUEST_CAMERA_ERROR\n);\n\n/* Query permission start */\n\nexport const ACTION_QUERY_PERMISSION_START = 'QUERY_PERMISSION_START';\n\nexport interface ActionQueryPermissionStart extends Action<typeof ACTION_QUERY_PERMISSION_START> {}\n\nexport const isActionQueryPermissionStart = (action: Action): action is ActionQueryPermissionStart => (\n  action.type === ACTION_QUERY_PERMISSION_START\n);\n\n/* Query permission success */\n\nexport const ACTION_QUERY_PERMISSION_SUCCESS = 'QUERY_PERMISSION_SUCCESS';\n\nexport interface ActionQueryPermissionSuccess extends Action<typeof ACTION_QUERY_PERMISSION_SUCCESS> {\n  data: {\n    state: 'denied' | 'granted' | 'prompt';\n  };\n}\n\nexport const isActionQueryPermissionSuccess = (action: Action): action is ActionQueryPermissionSuccess => (\n  action.type === ACTION_QUERY_PERMISSION_SUCCESS\n);\n\n/* Query permission error */\n\nexport const ACTION_QUERY_PERMISSION_ERROR = 'QUERY_PERMISSION_ERROR';\n\nexport interface ActionQueryPermissionError extends Action<typeof ACTION_QUERY_PERMISSION_ERROR> {\n  data: {\n    message: string;\n  };\n}\n\nexport const isActionQueryPermissionError = (action: Action): action is ActionQueryPermissionError => (\n  action.type === ACTION_QUERY_PERMISSION_ERROR\n);\n\n/* Change permission */\n\nexport const ACTION_CHANGE_PERMISSION = 'CHANGE_PERMISSION';\n\nexport interface ActionChangePermission extends Action<typeof ACTION_CHANGE_PERMISSION> {\n  data: {\n    state: 'denied' | 'granted' | 'prompt';\n  };\n}\n\nexport const isActionChangePermission = (action: Action): action is ActionChangePermission => (\n  action.type === ACTION_CHANGE_PERMISSION\n);\n\nexport const changePermission = (state: 'denied' | 'granted' | 'prompt') => ({\n  type: ACTION_CHANGE_PERMISSION,\n  data: {\n    state,\n  },\n});\n\n/* Enumerate devices start */\n\nexport const ACTION_ENUMERATE_DEVICES_START = 'ENUMERATE_DEVICES_START';\n\nexport interface ActionEnumerateDevicesStart extends Action<typeof ACTION_ENUMERATE_DEVICES_START> {}\n\nexport const isActionEnumerateDevicesStart = (action: Action): action is ActionEnumerateDevicesStart => (\n  action.type === ACTION_ENUMERATE_DEVICES_START\n);\n\n/* Enumerate devices success */\n\nexport const ACTION_ENUMERATE_DEVICES_SUCCESS = 'ENUMERATE_DEVICES_SUCCESS';\n\nexport interface ActionEnumerateDevicesSuccess extends Action<typeof ACTION_ENUMERATE_DEVICES_SUCCESS> {\n  data: {\n    devices: MediaDeviceInfo[];\n  };\n}\n\nexport const isActionEnumerateDevicesSuccess = (action: Action): action is ActionEnumerateDevicesSuccess => (\n  action.type === ACTION_ENUMERATE_DEVICES_SUCCESS\n);\n\n/* Enumerate devices error */\n\nexport const ACTION_ENUMERATE_DEVICES_ERROR = 'ENUMERATE_DEVICES_ERROR';\n\nexport interface ActionEnumerateDevicesError extends Action<typeof ACTION_ENUMERATE_DEVICES_ERROR> {\n  data: {\n    message: string;\n  };\n}\n\nexport const isActionEnumerateDevicesError = (action: Action): action is ActionEnumerateDevicesError => (\n  action.type === ACTION_ENUMERATE_DEVICES_ERROR\n);\n\n/* Capture image */\n\nexport const ACTION_CAPTURE_IMAGE = 'CAPTURE_IMAGE';\n\nexport interface ActionCaptureImage extends Action<typeof ACTION_CAPTURE_IMAGE> {\n  data: {\n    imageSrc: string;\n  };\n}\n\nexport const isActionCaptureImage = (action: Action): action is ActionCaptureImage => (\n  action.type === ACTION_CAPTURE_IMAGE\n);\n\nexport const captureImage = (imageSrc: string) => ({\n  type: ACTION_CAPTURE_IMAGE,\n  data: {\n    imageSrc,\n  },\n});\n","import { AnyAction } from 'redux';\r\nimport { useDispatch as useReactReduxDispatch } from 'react-redux';\r\nimport { ThunkDispatch } from 'redux-thunk';\r\nimport { RootReducerState } from '.';\r\n\r\nexport const useDispatch: () => ThunkDispatch<RootReducerState, void, AnyAction> = useReactReduxDispatch;\r\n","import { useSelector as useReactReduxSelector, TypedUseSelectorHook } from 'react-redux';\r\nimport { RootReducerState } from '.';\r\n\r\nexport const useSelector: TypedUseSelectorHook<RootReducerState> = useReactReduxSelector;\r\n","import { Reducer } from 'redux';\nimport {\n  isActionRequestCameraStart,\n  isActionRequestCameraSuccess,\n  isActionRequestCameraError,\n  isActionQueryPermissionSuccess,\n  isActionChangePermission,\n  isActionEnumerateDevicesSuccess,\n  isActionCaptureImage,\n} from './actions';\n\nexport * from './use-dispatch';\nexport * from './use-selector';\n\nexport interface RootReducerState {\n  version: undefined | string;\n  devices: null | MediaDeviceInfo[];\n  videoInputDeviceCount: null | number;\n  cameraPermission: null | 'denied' | 'granted' | 'prompt';\n  isRequestingCamera: boolean;\n  requestCameraError: null | string;\n  captures: string[];\n}\n\nexport const DEFAULT_STATE: RootReducerState = {\n  version: process.env.REACT_APP_VERSION,\n  devices: null,\n  videoInputDeviceCount: null,\n  cameraPermission: null,\n  isRequestingCamera: false,\n  requestCameraError: null,\n  captures: [],\n};\n\nexport const reducer: Reducer = (state = DEFAULT_STATE, action) => {\n  if (isActionRequestCameraStart(action)) {\n    return {\n      ...state,\n      isRequestingCamera: true,\n    };\n  }\n\n  if (isActionRequestCameraSuccess(action)) {\n    return {\n      ...state,\n      isRequestingCamera: false,\n    };\n  }\n\n  if (isActionRequestCameraError(action)) {\n    const { message } = action.data;\n    return {\n      ...state,\n      isRequestingCamera: false,\n      requestCameraError: message,\n    };\n  }\n\n  if (isActionQueryPermissionSuccess(action) || isActionChangePermission(action)) {\n    return {\n      ...state,\n      cameraPermission: action.data.state,\n    };\n  }\n\n  if (isActionEnumerateDevicesSuccess(action)) {\n    const { devices } = action.data;\n    const videoInputDevices = devices.filter((device) => device.kind === 'videoinput');\n    const videoInputDeviceCount = videoInputDevices.length;\n    return {\n      ...state,\n      devices,\n      videoInputDeviceCount,\n    };\n  }\n\n  if (isActionCaptureImage(action)) {\n    const { imageSrc } = action.data;\n    return {\n      ...state,\n      captures: [\n        ...state.captures,\n        imageSrc,\n      ],\n    };\n  }\n\n  return state;\n};\n\nexport default reducer;\n\nexport const getDevices = (state: RootReducerState) => state.devices;\nexport const getVideoInputDeviceCount = (state: RootReducerState) => state.videoInputDeviceCount;\nexport const getCameraPermission = (state: RootReducerState) => state.cameraPermission;\nexport const isRequestingCamera = (state: RootReducerState) => state.isRequestingCamera;\nexport const getCameraError = (state: RootReducerState) => state.requestCameraError;\nexport const getCaptures = (state: RootReducerState) => state.captures;\n","import * as React from 'react';\n\nexport type StreamType = MediaStream | null\nexport type VideoType = HTMLVideoElement | null\nexport type SetStreamType = (stream: StreamType) => void\n\nexport interface StreamContextType {\n  stream: StreamType;\n  video: VideoType;\n  setStream: SetStreamType;\n}\n\nexport const StreamContext = React.createContext<StreamContextType>({\n  stream: null,\n  video: null,\n  setStream() {},\n});\n\nexport interface Props {\n  stream?: MediaStream;\n}\n\nexport const StreamProvider: React.FC<Props> = ({ stream: streamProp, children }) => {\n  const [stream, setStreamState] = React.useState<StreamType>(streamProp || null);\n  const video = React.useRef<HTMLVideoElement>(document.createElement('video'));\n  const setStream = React.useCallback<SetStreamType>((stream) => setStreamState(stream), []);\n\n  React.useEffect(() => {\n    video.current.autoplay = true;\n    video.current.srcObject = stream;\n  }, [stream]);\n\n  return (\n    <StreamContext.Provider value={{ stream, video: video.current, setStream }}>\n      {children}\n    </StreamContext.Provider>\n  );\n};\n\nexport default StreamProvider;\n\nexport const useStream = (): [StreamType, SetStreamType] => {\n  const context = React.useContext(StreamContext);\n  return [context.stream, context.setStream];\n};\n\nexport const useVideo = (): VideoType => {\n  const context = React.useContext(StreamContext);\n  return context.video;\n};\n","import * as React from 'react';\nimport { useStream } from './Stream';\nimport './Camera.css';\n\nconst Camera: React.FC = () => {\n  const videoRef = React.useRef<HTMLVideoElement>(null);\n  const [stream] = useStream();\n\n  React.useEffect(() => {\n    const video = videoRef.current;\n    if (!video) return;\n    video.srcObject = stream;\n  }, [stream]);\n\n  return (\n    <div className=\"Camera\">\n      <video className=\"Camera-video\" autoPlay={true} ref={videoRef} />\n    </div>\n  );\n};\n\nexport default Camera;\n","import * as React from 'react';\nimport { useDispatch } from '../store';\nimport { useVideo } from './Stream';\nimport { capture } from '../store/actions';\nimport './ButtonCapture.css';\n\nexport interface Props extends React.ButtonHTMLAttributes<HTMLButtonElement> {}\n\nconst ButtonCapture: React.FC<Props> = ({ onTouchStart, ...props }) => {\n  const dispatch = useDispatch();\n  const video = useVideo();\n  const [disabled, setDisabled] = React.useState(false);\n\n  const handleTouchStart = React.useCallback<React.TouchEventHandler<HTMLButtonElement>>(async (e) => {\n    if (disabled) return;\n    e.preventDefault();\n    try {\n      if (!video) throw new Error('Expected video element');\n      await dispatch(capture(video));\n    } catch (err) {}\n    setDisabled(true);\n    if (onTouchStart) onTouchStart(e);\n  }, [disabled, dispatch, video, onTouchStart]);\n\n  React.useEffect(() => {\n    if (!disabled) return;\n    const timeout = setTimeout(() => setDisabled(false), 200);\n    return () => clearTimeout(timeout);\n  }, [disabled]);\n\n  return (\n    <button\n      className=\"ButtonCapture\"\n      onTouchStart={handleTouchStart}\n      disabled={disabled}\n      {...props}\n    />\n  );\n};\n\nexport default ButtonCapture;\n","import * as React from 'react';\nimport { useStream } from './Stream';\nimport { useDispatch } from '../store';\nimport { requestCamera } from '../store/actions';\n\nexport interface Props extends React.ButtonHTMLAttributes<HTMLButtonElement> {}\n\nconst ButtonRequestUserCamera: React.FC<Props> = ({ onClick, ...props }) => {\n  const dispatch = useDispatch();\n  const [, setStream] = useStream();\n\n  const handleClick: React.MouseEventHandler = async (e) => {\n    e.preventDefault();\n    try {\n      const stream = await dispatch(requestCamera('user'));\n      setStream(stream);\n    } catch (err) {}\n  };\n\n  return (\n    <button onClick={handleClick} {...props} />\n  );\n};\n\nexport default ButtonRequestUserCamera;\n","import * as React from 'react';\nimport { useStream } from './Stream';\nimport { useDispatch } from '../store';\nimport { requestCamera } from '../store/actions';\n\nexport interface Props extends React.ButtonHTMLAttributes<HTMLButtonElement> {}\n\nconst ButtonRequestEnvironmentCamera: React.FC<Props> = ({ onClick, ...props }) => {\n  const dispatch = useDispatch();\n  const [, setStream] = useStream();\n\n  const handleClick: React.MouseEventHandler = async (e) => {\n    e.preventDefault();\n    try {\n      const stream = await dispatch(requestCamera('environment'));\n      setStream(stream);\n    } catch (err) {}\n  };\n\n  return (\n    <button onClick={handleClick} {...props} />\n  );\n};\n\nexport default ButtonRequestEnvironmentCamera;\n","import * as React from 'react';\nimport { useStream } from './Stream';\n\nexport interface Props extends React.ButtonHTMLAttributes<HTMLButtonElement> {}\n\nconst ButtonCancelRequest: React.FC<Props> = ({ onClick, ...props }) => {\n  const [stream, setStream] = useStream();\n\n  const handleClick: React.MouseEventHandler = async (e) => {\n    e.preventDefault();\n    try {\n      if (!stream) throw new Error('Expected stream');\n      stream.getTracks().forEach((track) => track.stop());\n      setStream(null);\n    } catch (err) {}\n  };\n\n  return (\n    <button onClick={handleClick} {...props} />\n  );\n};\n\nexport default ButtonCancelRequest;\n","import * as React from 'react';\r\nimport { useStream } from './Stream';\r\n\r\nconst CancelOnPageHidden: React.FC = () => {\r\n  const [stream, setStream] = useStream();\r\n\r\n  React.useEffect(() => {\r\n    const handleVisibilityChange = () => {\r\n      if (document.hidden) {\r\n        stream?.getTracks().forEach((track) => track.stop());\r\n        setStream(null);\r\n      }\r\n    };\r\n    document.addEventListener('visibilitychange', handleVisibilityChange);\r\n    return () => document.removeEventListener('visibilitychange', handleVisibilityChange);\r\n  }, [stream, setStream]);\r\n\r\n  return null;\r\n};\r\n\r\nexport default CancelOnPageHidden;\r\n","import * as React from 'react';\r\nimport './Flash.css';\r\n\r\nconst Flash = React.forwardRef((_props, ref) => {\r\n  const divRef = React.useRef<HTMLDivElement>(null);\r\n\r\n  React.useImperativeHandle(ref, () => ({\r\n    start() {\r\n      const div = divRef.current;\r\n      if (!div) return;\r\n      div.classList.remove('Flash--capture');\r\n      // Trigger reflow\r\n      void div.offsetWidth;\r\n      div.classList.add('Flash--capture');\r\n    },\r\n  }));\r\n\r\n  return <div className=\"Flash\" ref={divRef} />;\r\n});\r\n\r\nexport default Flash;\r\n","import * as React from 'react';\r\nimport './BackgroundEmpty.css';\r\n\r\nexport interface Props extends React.HTMLAttributes<HTMLDivElement> {}\r\n\r\nconst BackgroundEmpty: React.FC<Props> = (props) => (\r\n  <div className=\"BackgroundEmpty\" {...props} />\r\n);\r\n\r\nexport default BackgroundEmpty;\r\n","import * as React from 'react';\r\nimport './Masking.css';\r\n\r\nexport interface Props extends React.HTMLAttributes<HTMLDivElement> {}\r\n\r\nconst Masking: React.FC<Props> = (props) => (\r\n  <div className=\"Masking\" {...props} />\r\n);\r\n\r\nexport default Masking;\r\n","import * as React from 'react';\nimport {\n  getCameraError,\n  getCameraPermission,\n  getVideoInputDeviceCount,\n  isRequestingCamera,\n  useSelector,\n} from '../store';\nimport Camera from './Camera';\nimport Capture from './ButtonCapture';\nimport RequestUserCamera from './ButtonRequestUserCamera';\nimport RequestEnvironmentCamera from './ButtonRequestEnvironmentCamera';\nimport CancelRequest from './ButtonCancelRequest';\nimport CancelOnPageHidden from './CancelOnPageHidden';\nimport Flash from './Flash';\nimport BackgroundEmpty from './BackgroundEmpty';\nimport Masking from './Masking';\nimport './App.css';\n\nconst App: React.FC = () => {\n  const videoInputDeviceCount = useSelector(getVideoInputDeviceCount);\n  const cameraPermission = useSelector(getCameraPermission);\n  const requestingCamera = useSelector(isRequestingCamera);\n  const cameraError = useSelector(getCameraError);\n\n  const flashRef = React.useRef<{ start: () => void }>();\n  const handleClickCapture = () => {\n    const flash = flashRef.current;\n    if (!flash) return;\n    flash.start();\n  };\n\n  return (\n    <div className=\"App\">\n      <CancelOnPageHidden />\n\n      <Capture onTouchStart={handleClickCapture} />\n\n      <div className=\"App-controls\">\n        <code>{videoInputDeviceCount} device(s). {cameraPermission || 'unknown'}. {String(requestingCamera)}. {cameraError || 'none'}.</code><br />\n\n        <RequestUserCamera>\n          Request user camera\n        </RequestUserCamera>\n        <RequestEnvironmentCamera>\n          Request environment camera\n        </RequestEnvironmentCamera>\n        <CancelRequest>\n          Close camera\n        </CancelRequest>\n      </div>\n\n      <Flash ref={flashRef} />\n\n      <Masking />\n\n      <Camera />\n\n      <BackgroundEmpty />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","/** See https://css-tricks.com/the-trick-to-viewport-units-on-mobile/ */\r\nexport const updateVH = () => document.documentElement.style.setProperty('--vh', window.innerHeight * 0.01 + 'px');\r\n\r\nwindow.addEventListener('resize', updateVH);\r\n\r\nupdateVH();\r\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\nimport { createStore, applyMiddleware } from 'redux';\nimport rootReducer, { RootReducerState } from './store';\nimport { composeWithDevTools } from 'redux-devtools-extension';\nimport thunk, { ThunkMiddleware } from 'redux-thunk';\nimport { Provider as StoreProvider } from 'react-redux';\nimport { queryPermission, changePermission, enumerateDevices } from './store/actions';\nimport StreamProvider from './components/Stream';\nimport './update-vh';\nimport './styles.css';\n\nconst store = createStore(rootReducer, composeWithDevTools(\n  applyMiddleware(\n    thunk as ThunkMiddleware<RootReducerState>,\n  ),\n));\n\n(async () => {\n  try {\n    const status = await store.dispatch(queryPermission());\n    status.addEventListener('change', () => {\n      store.dispatch(changePermission(status.state));\n    });\n  } catch (err) {}\n})();\n\n(async () => {\n  try {\n    await store.dispatch(enumerateDevices());\n  } catch (err) {}\n})();\n\nwindow.addEventListener('unload', () => {\n  const state = store.getState();\n  const blob = new Blob([JSON.stringify(state)], {\n    type: 'application/json; charset=UTF-8',\n  });\n  navigator.sendBeacon('/beacon', blob);\n});\n\nReactDOM.render(\n  <React.StrictMode>\n    <StoreProvider store={store}>\n      <StreamProvider>\n        <App />\n      </StreamProvider>\n    </StoreProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n","import { ThunkAction } from 'redux-thunk';\nimport { RootReducerState } from '.';\nimport {\n  ACTION_QUERY_PERMISSION_ERROR,\n  ACTION_QUERY_PERMISSION_START,\n  ACTION_QUERY_PERMISSION_SUCCESS,\n  ActionQueryPermissionError,\n  ActionQueryPermissionStart,\n  ActionQueryPermissionSuccess,\n} from './actions';\n\ntype R = Promise<PermissionStatus>\ntype S = RootReducerState\ntype E = void\ntype A = (\n  ActionQueryPermissionError |\n  ActionQueryPermissionStart |\n  ActionQueryPermissionSuccess\n)\n\nexport type ActionQueryPermission = ThunkAction<R, S, E, A>\n\nexport const queryPermission = (): ActionQueryPermission => async (dispatch) => {\n  dispatch<ActionQueryPermissionStart>({\n    type: ACTION_QUERY_PERMISSION_START,\n  });\n  try {\n    if (\n      typeof navigator.permissions === 'undefined' ||\n      typeof navigator.permissions.query !== 'function'\n    ) {\n      throw new Error('Navigator permission query API not available');\n    }\n    const status = await navigator.permissions.query({ name: 'camera' });\n    const state = status.state;\n    if (\n      // \"Block\"\n      state !== 'denied' &&\n      // \"Allow\"\n      state !== 'granted' &&\n      // \"Ask (default)\"\n      state !== 'prompt'\n    ) {\n      throw new Error('Unrecognised permission state: ' + state);\n    }\n    dispatch<ActionQueryPermissionSuccess>({\n      type: ACTION_QUERY_PERMISSION_SUCCESS,\n      data: {\n        state: status.state,\n      },\n    });\n    return status;\n  } catch (err) {\n    dispatch<ActionQueryPermissionError>({\n      type: ACTION_QUERY_PERMISSION_ERROR,\n      data: {\n        message: err.message,\n      },\n    });\n    throw err;\n  }\n};\n","import { ThunkAction } from 'redux-thunk';\nimport { RootReducerState } from '.';\nimport {\n  ACTION_ENUMERATE_DEVICES_ERROR,\n  ACTION_ENUMERATE_DEVICES_START,\n  ACTION_ENUMERATE_DEVICES_SUCCESS,\n  ActionEnumerateDevicesError,\n  ActionEnumerateDevicesStart,\n  ActionEnumerateDevicesSuccess,\n} from './actions';\n\ntype R = Promise<MediaDeviceInfo[]>\ntype S = RootReducerState\ntype E = void\ntype A = (\n  ActionEnumerateDevicesError |\n  ActionEnumerateDevicesStart |\n  ActionEnumerateDevicesSuccess\n)\n\nexport type ActionEnumerateDevices = ThunkAction<R, S, E, A>\n\nexport const enumerateDevices = (): ActionEnumerateDevices => async (dispatch) => {\n  dispatch<ActionEnumerateDevicesStart>({\n    type: ACTION_ENUMERATE_DEVICES_START,\n  });\n  try {\n    if (\n      typeof navigator.mediaDevices === 'undefined' ||\n      typeof navigator.mediaDevices.enumerateDevices !== 'function'\n    ) {\n      throw new Error('Navigator enumerate devices API not available');\n    }\n    const deviceInfo = await navigator.mediaDevices.enumerateDevices();\n    dispatch<ActionEnumerateDevicesSuccess>({\n      type: ACTION_ENUMERATE_DEVICES_SUCCESS,\n      data: {\n        devices: deviceInfo,\n      },\n    });\n    return deviceInfo;\n  } catch (err) {\n    dispatch<ActionEnumerateDevicesError>({\n      type: ACTION_ENUMERATE_DEVICES_ERROR,\n      data: {\n        message: err.message,\n      },\n    });\n    throw err;\n  }\n};\n"],"sourceRoot":""}